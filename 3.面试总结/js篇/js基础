 闭包 

闭包就是能够读取其他函数内部变量的函数
闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的常见的方式就是在一个 
函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,
利用闭包可以突破作用 链域
闭包的特性：
函数内再嵌套函数 内部函数可以引用外层的参数和变量 参数和变量不会被垃圾回收机制回收

说说你对闭包的理解

使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺 点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。
在js中，函数 即闭包，只有函数才会产生作用域的概念 闭包 的大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保 持在内存中
闭包的另一个用处，是封装对象的私有属性和私有方法
好处：能够实现封装和缓存等；
坏处：就是消耗内存、不正当使用会造成内存溢出的问题

使用闭包的注意点
由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否 则会造成网页的性能问题，
在IE中可能导致内存泄露 解决方法是，在退出函数之前，将不使用的局部变量全部删除

说说你对作用域链的理解 

作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，
作用域链的变量只能 向上访问，变量访问到 window 对象即被终止，
作用域链向下访问变量是不被允许的 
简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和 生命周期

JavaScript原型，原型链 ? 有什么特点？ 
每个对象都会在其内部初始化一个属性，就是 prototype (原型)，
当我们访问一个对象的 属性时如果这个对象内部不存在这个属性，那么他就会去 prototype 里找这个属性，
这个 prototype 又会有自己的 prototype ，于是就这样一直找下去，也就是我们平时所说的 原型链的概念
关系： instance.constructor.prototype = instance.__proto__
特点：
JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于 自己的原型副本。
当我们修改原型时，与之相关的对象也会继承这一改变
当我们需要一个属性的时， Javascript 引擎会先看当前对象中是否有这个属性， 
如果没 有的 就会查找他的 Prototype 对象是否有这个属性，如此递推下去，一直检索到 Object 内 建对象

 请解释什么是事件代理 事件代理（ Event Delegation ）

 又称之为事件委托。是 JavaScript 中常用绑定事件 的常用技巧。顾名思义，
 “事件代理”即是把原本需要绑定的事件委托给父元素，让父元素 担当事件监听的职务。
 事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可 以提高性能 
 可以大量节省内存占用，减少事件注册，比如在 table 上代理所有 td 的 click 事件就 非常棒 可以实现当新增子对象时无需再次对其绑定

Javascript如何实现继承？ 构造继承

          原型继承
  实例继承
               拷贝继承
    原型 prototype 机制或 apply 和 call 方法去实现较简单，建议使用构造函数与原型混 合方式

 用过哪些设计模式？ 

 工厂模式： 工厂模式解决了重复实例化的问题，但还有一个问题,那就是识别问题，
 因为根本无法 主要好处就是可以消除对象间的耦合，通过使用工程方法而不是 new 关键字

 构造函数模式
 使用构造函数的方法，即解决了重复实例化的问题，又解决了对象识别的问题，
 该模式 与工厂模式的不同之处在于 
 直接将属性和方法赋值给 this 对象;

 说说你对promise的了解 依照 Promise/A+ 的定义

  Promise 有四种状态： pending: 初始状态, 非 fulfilled 或 rejected.
  body,ul,li,ol,dl,dt,dd,form,input,h1,h2,h3,h4,h5,h6,p{ margin:0; padding:0; }
  css
  fulfilled: 成功的操作. rejected: 失败的操作.
   settled: Promise 已被 fulfilled 或 rejected ，且不是 pending 另外， 
   fulfilled 与 rejected 一起合称 settled Promise 对象用来进行延迟( deferred ) 和异步( asynchronous ) 计算 

   Promise 的构造函数 构造一个 Promise ，基本的用法如下：

   var promise = new Promise(function(resolve, reject) { 
 
        if (...) {  // succeed 
 
            resolve(result); 
 
        } else {   // fails 
 
            reject(Error(errMessage)); 
 
        }     })

  Promise 实例拥有 then 方法（具有 then 方法的对象，通常被称为 thenable ）。它 的使用方法如下：

  promise.then(onFulfilled, onRejected) 


  Node的应用场景 特点：
  
   它是一个 Javascript 运行环境 2、依赖于 Chrome V8 引擎进行代码解释 3、事件驱动 4、非阻塞 I/O 5、单进程，单线程

   优点：高并发（重要的优点）

   缺点： 1、只支持单核 CPU ，不能充分利用 CPU 2、可靠性低，一旦代码某个环节崩溃，整个系统都崩溃

   那些操作会造成内存泄漏 
   
   内存泄漏指任何对象在您不再拥有或需要它之后仍然存在 setTimeout 的第一个参数使用字符串而非函数的话，

   会引发内存泄漏 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）

   


